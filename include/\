#pragma once
#include <functional>
#include <string>
#include <map>
#include <memory>
#include <any>
#include <cxxabi.h>
#include <typeinfo>

#include "bicycle.h"

enum class Direction { IN, OUT };
enum class ActionState { READY, FAILED, IN_PROGRESS, SUCCESS };
using ActFunc = std::function<ActionState()>;
using BbKey = std::string;

struct Port {
  Port( const std::type_index& type, const Direction&& dir ) : type( type ), dir( dir ) {}
  const std::type_index type;
  const Direction dir;
};

template<typename T>
struct InputPort : public Port {
  InputPort( const std::type_index& type ) : Port( type, Direction::IN ) {}
};

template<typename T>
struct OutputPort : public Port {
  OutputPort() : Port( std::type_index<T>, Direction::OUT ) {}
};

using PortPair = std::pair<BbKey, std::type_info>;

struct PortSet {
  const std::map<BbKey, InputPort> in;
  const std::map<BbKey, OutputPort> out;
};

// TODO How will you escape this horrible coding nightmare you're writing yourself into for every node?
static PortSet& getPortSet() {
  static PortSet ps = {
    { 
      { "1", double },
      { "2", int },
      { "3", ActFunc },
    },
    {
      { 

#define IN( key, type ) { key, InputPort{ typeid( type ) } }
#define OUT( key, type ) { key, OutputPort{ typeid( type ) } }

class Blackboard {
  public:
    template<typename T>
      auto get( const BbKey& key ) -> T {
        try {
          auto& val = _bb.at( key );
          try {
            return std::any_cast<T>( _bb.at( key ) ); 
          }
          // Catch bad casting of std::any.
          catch ( const std::bad_any_cast &e ) {
            int i;
            T t;
            auto actual = __cxxabiv1::__cxa_demangle( val.type().name(), nullptr, 0, &i );
            auto expect = __cxxabiv1::__cxa_demangle( typeid(t).name(), nullptr, 0, &i );
            bicycle::die( std::string("Your call to get<") + expect + ">( \"" + key + "\" ) should be get<" + actual + ">( \"" + key + "\" ).\n" );
          }
        }
        // Catch blackboard missing a key.
        catch ( const std::out_of_range& e ) {
          bicycle::die( "blackboard hasn't mapped for key " + key + " yet." );
        }
      }

    template <typename T>
      void set ( const BbKey& key, const T& val ) {
        _bb[ key ] = val;
      }

    template <typename T>
      void set ( const BbKey&& key, const T&& val ) {
        _bb[ key ] = val;
      }

  private:
    std::map<BbKey, std::any> _bb{};
};

class Action;
using ActionPtr = Action*;  // TODO Figure out how to make this a smart pointer due to circular dependency.

class ActionRegistry : public std::map<std::string, ActionPtr> {
  public:
    static auto getInstance() -> ActionRegistry& {
      static ActionRegistry registry;
      return registry;
    }
    // Allows you to more easily make an event mapping
    auto get( const std::string& name ) const -> ActionPtr {
      try {
        return at( name );
      }
      catch ( const std::out_of_range& e ) {
        bicycle::die( "Action Registry hasn't mapped anything yet to key " + name + "." );
      }
    }
    // Allows you to more easily make an event mapping
    void set( const std::string& name, const ActionPtr& action ) {
      if ( action == nullptr ) {
        bicycle::die( "ActionRegistry::set(): ActionPtr " + name + " is null!" );
      }
      (*this)[name] = action;
    }

  private:
    ActionRegistry() = default;
    ActionRegistry( const ActionRegistry& rhs ) = delete;
    ActionRegistry& operator=( const ActionRegistry& ) = delete;
};

/* Although ActionFunc and ActionNode may seem already sufficient for behavior trees,
 * the Action class exists as a practical necessity: parameter-less action funcs can't
 * know about blackboards unless they're declared within the scope of a class/struct. 
 * And ActionNodes are read from YAMLs; we're not going to define a different YAML type
 * for every Action, so it's more feasible to separate the two. */

/* Since we can't make static member functions virtual, we'll enforce a concept on 
 * on Action's derived children. */

class Action {
  public:
    Action() = default;
    Action( const std::string&& name, const ActFunc& f ) : f(f) {
      auto& reg = ActionRegistry::getInstance();
      // Protect devs from null function pointers.
      if ( f == nullptr ) {
        bicycle::die( "Action::Action(): Action " + name + "'s function is null!" );
      }
      reg.set( name, this );
    }

    void setBlackboard( std::shared_ptr<Blackboard> bb ) {
      _bb = bb;
    }

    // TODO there may need to be a reference variant of these. 
    //      Wonder how we do that since any_cast() forces copying.
    template<typename T>
      // TODO 
      auto get( const BbKey& key ) -> T {
        return _bb->get<T>( key );
      }

    template<typename T>
      void set( const BbKey& key, T&& val ) {
        _bb->set<T>( key, std::forward<T>( val ) );
      }

    ActFunc f{};  // nullptr by default; guess they're ultimately function pointers

  private:
    std::shared_ptr<Blackboard> _bb{ std::make_shared<Blackboard>() };
};


template<typename T>
concept HasStaticGetPortSet = requires { { &T::Test } -> std::same_as<PortSet& (T::*)()>; };

// macro for defining actions
#define ACT( _type_, _portSet_, ... )\
  namespace _type_ {\
    struct _type_ : public Action {\
      _type_() : Action( #_type_, __VA_ARGS__ ) {}\
      static int Test() { return 1; }\
      \
    };\
    /* GCC 12.2.0 work-around: Bug in compiler requires complete class definitions before member-accessing constraints are tested. */\
    static_assert( HasStaticGetPortSet<_type_> );\
    static _type_ _;\
  }
